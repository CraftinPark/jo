
function optimallyAddMemberToJos(jos: member[][], unaddedMembers: member[]): Promise<void> {
   return new Promise((resolve) => {
      setTimeout(() => {
         let mockPossibilities: member[][][] = [];
         for (let i = 0; i < jos.length; i++) {
            let mockPossibility: member[][] = [];
            for (let j = 0; j < jos.length; j++) mockPossibility[j] = jos[i].slice();
            mockPossibilities.push(mockPossibility);
         }
         let possibleUnaddedMembers: member[][] = [];
         for (let i = 0; i < jos.length; i++) possibleUnaddedMembers.push([...unaddedMembers]);

         // // fill mockPossibilities
         for (let p = 0; p < mockPossibilities.length; p++) {
            let mockJos = [...mockPossibilities[p]];
            let mockUnaddedMembers = possibleUnaddedMembers[p];
            let bestChoiceIndex = findJoBestChoice(mockJos, p, mockUnaddedMembers);
            mockJos[p].push(mockUnaddedMembers[bestChoiceIndex]);
            mockUnaddedMembers.splice(bestChoiceIndex, 1);
               mockUnaddedMembers.splice(bestChoiceIndex, 1);
               if (mockJos.length > 1) {
                  let thisJo: member[] = [...mockJos][p];
                  mockJos.splice(p, 1);
                  optimallyAddMemberToJos(mockJos, mockUnaddedMembers);
                  mockJos.splice(p, 1, thisJo);
               }
         }
         console.log(util.inspect(mockPossibilities, { showHidden: false, depth: null, colors: true }));

         let mockScores = mockPossibilities.map((mockJo) => calculateTotalScore(mockJo));
         let smallestTotalScore = Math.min(...mockScores);
         let optimalJoToGiveFirstChoice = mockScores.indexOf(smallestTotalScore);
         console.log("give first choice to " + optimalJoToGiveFirstChoice);
         Object.assign(jos, mockPossibilities[optimalJoToGiveFirstChoice], {
            length: mockPossibilities[optimalJoToGiveFirstChoice].length,
         });
         Object.assign(unaddedMembers, possibleUnaddedMembers[optimalJoToGiveFirstChoice], {
            length: possibleUnaddedMembers[optimalJoToGiveFirstChoice].length,
         });
         resolve();
      }, 2000);
   });
}

function optimallyAddMemberToJoswrong(jos: member[][], unaddedMembers: member[]): member[][] {
   let mockPossibilities: member[][][] = [];
   for (let i = 0; i < jos.length; i++) mockPossibilities.push([...jos]);
   // mockPossibilities are 3 identical copies of our jos.
   // console.log(mockPossibilities);

   let possibleUnaddedMembers: member[][] = [];
   for (let i = 0; i < jos.length; i++) possibleUnaddedMembers.push([...unaddedMembers]);

   for (let p = 0; p < mockPossibilities.length; p++) {
      let mockJos = mockPossibilities[p];
      let mockUnaddedMembers = possibleUnaddedMembers[p];
      // if there are still unadded members,
      // give our jo it's first choice.
      // otherwise, leave jo as is.
      let bestChoiceIndex: number = findJoBestChoice(mockJos, p, mockUnaddedMembers);
      mockJos[p].push(mockUnaddedMembers[bestChoiceIndex]);
      mockUnaddedMembers.splice(bestChoiceIndex, 1);
      // console.log("mockJos: ");
      // console.log(mockJos);
      // if there is more than 1 jo, fill the rest with it's optimal solution.
      if (mockJos.length > 1) {
         let ourJo: member[] = [...mockJos][p];
         mockJos.splice(p, 1);
         mockJos = optimallyAddMemberToJos(mockJos, mockUnaddedMembers);
         mockJos.splice(p, 1, ourJo);
      }
   }

   // we gave every jo their first choice. They came up with an optimal solution. Let's see which one was truly optimal.
   let mockScores = mockPossibilities.map((mockJo) => calculateTotalScore(mockJo));
   let smallestTotalScore = Math.min(...mockScores);
   let optimalJoToGiveFirstChoice = mockScores.indexOf(smallestTotalScore);
   // let it be done then, allow jo that would produce the best results to have its way
   // set true jos to its mock jo.
   console.log("unadded members");
   console.log(unaddedMembers);
   for (let i = 0; i < unaddedMembers.length; i++) {
      if (!possibleUnaddedMembers[optimalJoToGiveFirstChoice].includes(unaddedMembers[i])) {
         unaddedMembers.splice(i, 1);
      }
      console.log(unaddedMembers);
   }
   console.log(unaddedMembers);
   return mockPossibilities[optimalJoToGiveFirstChoice];
}

function optimallyAddMemberToJosBackup(jos: member[][], unaddedMembers: member[]): member[][] {
   let mockPossibilities: member[][][] = [];
   for (let i = 0; i < jos.length; i++) mockPossibilities.push(jos);

   for (let p = 0; p < mockPossibilities.length; p++) {
      let mockJos = [...jos];
      let mockUnaddedMembers = [...unaddedMembers];
      findJoBestChoice(mockJos, p, mockUnaddedMembers);

      // mockJos has now added a member to a jo.
      // it has also taken out that member out of the list of unadded members.
      // find the next best way to add members to the rest of the jos.
      let addedMemberJo = mockJos[p];
      let remainingJos = mockJos.splice(p, 1);
      if (mockJos.length > 0) {
         let optimalRemainingJos: member[][] = optimallyAddMemberToJos(remainingJos, mockUnaddedMembers);
         let optimalJos = optimalRemainingJos.splice(p, 1, addedMemberJo);
         mockJos = [...optimalJos];
      }
   }

   // we gave every jo their first choice. Let's see which one was truly optimal.
   let mockScores = mockPossibilities.map((mockJo) => calculateTotalScore(mockJo));
   let smallestTotalScore = Math.min(...mockScores);
   let optimalJoToGiveFirstChoice = mockScores.indexOf(smallestTotalScore);
   // let it be done then, allow jo that would produce the best results to have its way
   // set true jos to its mock jo.
   return mockPossibilities[optimalJoToGiveFirstChoice];
}