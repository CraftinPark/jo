// function createJos(n: number, list: member[], debug: boolean) {
//    let jos: member[][] = [];
//    for (let i = 0; i < n; i++) jos.push([]);

//    let unaddedMembers: member[] = list;
//    shuffleMembers(unaddedMembers);

//    // console.log("start createJos");
//    // console.log(jos);
//    // if (debug) await continuePrompt();

//    // console.log("initilaize jos with most similar member");
//    initializeJos(jos, unaddedMembers);
//    // console.log("the best weve come up with");
//    // console.log(jos);
//    // console.log(unaddedMembers);

//    // if (debug) await continuePrompt();

//    while (unaddedMembers.length > 0) {
//       optimallyAddMemberToJos(jos, unaddedMembers, 0);
//       // console.log(jos);
//       // if (debug) await continuePrompt();
//    }

//    let totalScore: number = calculateTotalScore(jos);
//    // console.log(totalScore);
//    return totalScore;
// }

// function initializeJos(jos: member[][], unaddedMembers: member[]) {
//    let highestScore = 0;
//    let highestScoringStart: member[][] = [];
//    let highestScoringUnaddedMembers: member[] = [];
//    for (let i = 0; i < unaddedMembers.length; i++) {
//       let possibleUnaddedMembers: member[] = [...unaddedMembers];
//       let mockStarts = [];
//       mockStarts.push(possibleUnaddedMembers[i]);
//       possibleUnaddedMembers.splice(i, 1);
//       for (let i = 0; i < jos.length - 1; i++) {
//          let mostSimilarMemberIndex = findMostSimilarMemberIndex(mockStarts, possibleUnaddedMembers);
//          mockStarts.push(possibleUnaddedMembers[mostSimilarMemberIndex]);
//          possibleUnaddedMembers.splice(mostSimilarMemberIndex, 1);
//       }
//       let score = calculateJoScore(mockStarts);
//       if (score > highestScore) {
//          highestScore = score;
//          highestScoringStart = [];
//          for (let j = 0; j < jos.length; j++) highestScoringStart.push([]);
//          for (let j = 0; j < mockStarts.length; j++) highestScoringStart[j].push(mockStarts[j]);
//          highestScoringUnaddedMembers = [];
//          for (let j = 0; j < possibleUnaddedMembers.length; j++)
//             highestScoringUnaddedMembers.push(possibleUnaddedMembers[j]);
//       }
//    }

//    Object.assign(jos, highestScoringStart, { length: highestScoringStart.length });
//    Object.assign(unaddedMembers, highestScoringUnaddedMembers, { length: highestScoringUnaddedMembers.length });
// }

// function findMostSimilarMemberIndex(mockStarts: member[], unaddedMembers: member[]) {
//    let highestScore = 0;
//    let highestScoringIndex = 0;
//    for (let i = 0; i < unaddedMembers.length; i++) {
//       let mockStartsWithPotential = [unaddedMembers[i], ...mockStarts];
//       let score = calculateJoScore(mockStartsWithPotential);
//       if (score > highestScore) {
//          highestScore = score;
//          highestScoringIndex = i;
//       }
//    }
//    return highestScoringIndex;
// }

// function optimallyAddMemberToJos(jos: member[][], unaddedMembers: member[], level: number): void {
//    let mockPossibilities: member[][][] = [];
//    for (let h = 0; h < jos.length; h++) {
//       let mockPossibility: member[][] = [];
//       for (let i = 0; i < jos.length; i++) mockPossibility.push([...jos[i]]);
//       mockPossibilities.push(mockPossibility);
//    }

//    let possibleUnaddedMembers: member[][] = [];
//    for (let i = 0; i < jos.length; i++) possibleUnaddedMembers.push([...unaddedMembers]);

//    for (let i = 0; i < mockPossibilities.length; i++) {
//       let mockJos = mockPossibilities[i];
//       let mockUnaddedMembers: member[] = possibleUnaddedMembers[i];
//       let bestChoiceIndex = findJoBestChoice(mockJos, i, mockUnaddedMembers);
//       if (mockUnaddedMembers.length > 0) {
//          mockJos[i].push(mockUnaddedMembers[bestChoiceIndex]);
//          mockUnaddedMembers.splice(bestChoiceIndex, 1);

//          if (mockJos.length > 1) {
//             let thisJo = [...mockJos[i]];
//             mockJos.splice(i, 1);
//             optimallyAddMemberToJos(mockJos, mockUnaddedMembers, level + 1);
//             mockJos.splice(i, 0, thisJo);
//          }
//       }
//    }

//    if (level === 0) {
//       // console.log(`level ${level} mock possibilities:`);
//       // console.log(mockPossibilities.length);
//       for (let i = 0; i < mockPossibilities.length; i++) {
//          // console.log(`possibility ${i}:`);
//          // console.log(JSON.stringify(mockPossibilities[i], null, 2));
//       }
//    }

//    let mockScores = mockPossibilities.map((mockJo) => {
//       return calculateTotalScore(mockJo);
//    });
//    let smallestTotalScore = Math.min(...mockScores);
//    let optimalJoToGiveFirstChoice = mockScores.indexOf(smallestTotalScore);
//    Object.assign(jos, mockPossibilities[optimalJoToGiveFirstChoice], {
//       length: mockPossibilities[optimalJoToGiveFirstChoice].length,
//    });
//    Object.assign(unaddedMembers, possibleUnaddedMembers[optimalJoToGiveFirstChoice], {
//       length: possibleUnaddedMembers[optimalJoToGiveFirstChoice].length,
//    });
// }

// function findJoBestChoice(jos: member[][], j: number, unaddedMembers: member[]): number {
//    let smallestScoringIndex: number = 0;
//    let smallestScore: number = 1000000000;
//    for (let i = 0; i < unaddedMembers.length; i++) {
//       let mockJo: member[] = [...jos[j]];
//       mockJo.push(unaddedMembers[i]);
//       let mockScore: number = calculateJoScore(mockJo);
//       if (mockScore < smallestScore) {
//          smallestScoringIndex = i;
//          smallestScore = mockScore;
//       }
//    }
//    return smallestScoringIndex;
// }

function shuffleMembers(members: member[]): void {
   for (let i = members.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [members[i], members[j]] = [members[j], members[i]];
   }
}

// ############################################################################
// SCORING SYSTEM
// - age score: a point for each member with same year as another member in jo
// - sex score: the difference in # of males to # of females in jo (unless only 1 member)
// - leader score: a point for each leader in a group (that is not the first leader)
// ############################################################################

function calculateTotalScore(jos: member[][]): number {
   let sum: number = 0;
   for (let i = 0; i < jos.length; i++) {
      // console.log("calculating score for jo #" + i);
      sum += calculateJoScore(jos[i]);
   }
   return sum;
}

function calculateJoScore(jo: member[]): number {
   let score: number = 0;
   score += ageScore(jo);
   score += sexScore(jo);
   score += leaderScore(jo);
   // console.log(score);
   return score;
}

function ageScore(jo: member[]): number {
   let score: number = 0;
   for (let i = 0; i < jo.length - 1; i++) {
      for (let j = i + 1; j < jo.length; j++) {
         if (jo[i].year === jo[j].year) score++;
      }
   }
   // console.log("age score is " + score);
   return score;
}

function sexScore(jo: member[]): number {
   if (jo.length <= 1) return 0;
   let score: number = 0;
   let numMale: number = 0;
   let numFemale: number = 0;
   for (let i = 0; i < jo.length; i++) {
      if (jo[i].sex === "male") numMale++;
      else if (jo[i].sex === "female") numFemale++;
   }
   score = Math.abs(numMale - numFemale);
   // console.log("sex score is " + score);
   return score;
}

function leaderScore(jo: member[]): number {
   let numLeaders: number = 0;
   for (let i = 0; i < jo.length; i++) {
      if (jo[i].leader === true) numLeaders++;
   }
   if (numLeaders > 0) return numLeaders - 1;
   else return 0;
}

const readline = require("readline");
function continuePrompt() {
   const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
   });

   return new Promise((resolve) =>
      rl.question("enter to continue", (ans: any) => {
         rl.close();
         resolve(ans);
      })
   );
}
